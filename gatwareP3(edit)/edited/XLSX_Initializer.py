global segfrom scipy.interpolate import *from scipy import interpolatefrom scipy import signalimport matplotlib.pyplot as pltimport numpy as npfrom win32com.client import Dispatchimport win32com.client as win32from math import *from XYPlot import *from xlrd import open_workbook#import pandas as pdfrom odict import *import win32xl = Dispatch("Excel.Application")#xl = win32.gencache.EnsureDispatch("Excel.Application")# from movingaverage import *xlToLeft = 1xlToRight = 2xlUp = 3xlDown = 4xlAscending = 1xlYes = 1def interpY(xa, xb, ya, yb, x_New):    x = [xa, xb]    y = [ya, yb]    return np.interp(x_New, x, y)def pcentile(obj, pcnt):    global data    select(obj)    data = MakeListFromColumn()    data = [float(i) for i in data]    # print np.percentile(data,pcnt)def qte(*args):    '''Adds quotation marks around argument such that the    argument can be passed to Excel'''    return "'%s'" % s1def deriv(var, spl, d):    ''' make a 'dth' derivative of a spline'''    return splev(var, spl, d)def pltconfig():    plt.grid(b='on', which='both')    plt.autoscale(enable=True, axis='both', tight=None)    plt.legend(loc='best')def MakeXRange(seq):    '''Create the time axis range to be used        throughout the analysis    '''    npoints = 750    global xmin, xmax    tmin = min(seq)    tmax = max(seq)    return np.linspace(tmin, tmax, npoints)def makespline(c1, c2):    """Create a spline from two columns of excel data. creates global 'tck'    :param c1:    :param c2:    :return:    """    global xvalues, yvalues, tck    select(c1)    xvalues = MakeListFromColumn()    xvalues = [float(i) for i in xvalues]    select(c2)    yvalues = MakeListFromColumn()    yvalues = [float(i) for i in yvalues]    tck = splrep(xvalues, yvalues)def select(obj):    'just selects the cell passed as argument'    xl.Range(obj).Select()def mavg(s1, n, s2):    global mavg, data    select(s1)    data = MakeListFromColumn()    mavg = list(movingaverage(data, n))    WriteColumn(s2, mavg)def MakeListFromColumn():    '''From the current cell, selects the entire column and returns a list with the values    '''    xl.Range(xl.Selection, xl.Selection.End(xlDown)).Select()    data = xl.Selection()    name = [obj[0] for obj in data]    return namedef MakeUniListFromColumn():    '''From the current cell, selects the entire column and returns a list with the values as strings    '''    xl.Range(xl.Selection, xl.Selection.End(xlDown)).Select()    data = xl.Selection()    name = [str(obj[0]) for obj in data]    return namedef PolyFitter(arg1, arg2, order):    global x, y, z, p, error    # select(arg1)    # x=MakeListFromColumn()    # x=[(180/pi)*i for i in x]    # select(arg2)    # y=MakeListFromColumn()    # y=[1000.*i for i in y]    select(arg2)    x = MakeListFromColumn()    x = [1000. * i for i in x]    select(arg1)    y = MakeListFromColumn()    y = [(180 / pi) * i for i in y]    xp = np.array(x)    yp = np.array(y)    z = np.polyfit(xp, yp, order)    p = np.poly1d(z)    yp = [p(i) for i in x]    error = [(i - j) for i, j in zip(y, yp)]    # print max(error)    fig = plt.figure()    ax = fig.add_subplot(2, 1, 1)    title = str(order)    title = 'Poly order ' + title    ax.set_title(title)    plt.grid(b='on', which='both')    plt.autoscale(enable=True, axis='both', tight=None)    ax.set_xlabel('Pusher Lift (mm)')    ax.set_ylabel('Crank Angle (deg)')    ax.plot(x, y, x, yp)    ax = fig.add_subplot(2, 1, 2)    plt.grid(b='on', which='both')    plt.autoscale(enable=True, axis='both', tight=None)    ax.set_xlabel('Pusher Lift (mm)')    ax.set_ylabel('Error(deg)')    ax.plot(x, error)def MakeListFromRow():    '''From the current cell, selects the entire row and returns a list with the values    '''    xl.Range(xl.Selection, xl.Selection.End(xlToRight)).Select()    data = xl.Selection()    name = [obj[0] for obj in data]    return namedef SelectEndRight(start):    '''From the specified cell, selects the cell at the end of the current row to the right    '''    xl.Range(start).Select()    xl.Selection.End(xlToRight).Select()def MakeNewWorkbook():    '''Makes a new workbook and activates sheet1    '''    xl.Workbooks.Add()    xl.Worksheets("Sheet1").Activate()    xl.Visible = 1def WriteColumn(col, seq):    '''usage---> WriteColumn("A1",sequence) '''    xl.Range(col).Activate()    for entry in seq:        xl.ActiveCell.Value = entry        xl.ActiveCell.Offset(2, 1).Select()def WriteRowFromSelected(seq):    for entry in seq:        #print(entry)        xl.ActiveCell.Value = entry        xl.ActiveCell.Offset(1, 2).Select()def WriteColumnFromSelected(seq):    for entry in seq:        xl.ActiveCell.Value = entry        xl.ActiveCell.Offset(2, 1).Select()def WriteCsv(filename, seq):    'Writes data to the filename given'    import csv    file = filename    f = open(file, 'wb')    c = csv.writer(f)    for row in seq:        c.writerow(row)    f.close()def rdl(s1):    ''' --> Row difference list    returns piecewise list of differences between items in an Excel row'''    return np.diff(MakeListFromRow())def cdl(s1, s2):    '''--> Column difference list -->cdl('source data', 'Write Target')    returns the piecewise list of differences between items    in an excel column'''    global l    xl.Range(s1).Select()    l = np.diff([i for i in MakeListFromColumn()])    WriteColumn(s2, l)def RMS(target):    global vals, seq, RMSseq    select(target)    xl.Range(xl.Selection, xl.Selection.End(xlDown)).Select()    values = xl.Selection()    vals = []    for i in values:        x = i[0]        vals.append(x)    seq = [[i][0] for i in values]    # print values    from math import sqrt    RMSseq = [sqrt(sum(n * n for n in vals) / len(vals))]    # print RMSseqdef MovingAvg(values, window):    weights = np.repeat(1.0, window) / window    ma = np.convolve(values, weights, 'valid')    return madef unitize(source, target):    '''selects the column of data specified by 'source' and   writes the unified data into the column denoted by  'target' '''    global l1, l2    xl.Range(source).Select()    l1 = MakeListFromColumn()    # print l1    # l1 = [[i][0][0] for i in l1]    l2 = [i / max(l1) for i in l1]    WriteColumn(target, l2)def ExactPoints(s1, s2, pnts, target):    global x, y, newx, newy    xl.Range(s1).Select()    x = MakeListFromColumn()    xl.Range(s2).Select()    y = MakeListFromColumn()    # print y    tck = splrep(x, y)    newx = np.linspace(x[0], max(x), pnts)    newy = [splev(i, tck) for i in newx]    WriteColumn(target, newx)    xl.Range(target).Select()    xl.ActiveCell.Offset(1, 2).Select()    newy = [float(i) for i in newy]    for entry in newy:        xl.ActiveCell.Value = entry        xl.ActiveCell.Offset(2, 1).Select()def ExactPointsTimeSpec(s1, s2, timevector, target):    ''' Select two columns of data and make a spline. Then using an existing vector of time values    create new values from the spline such that the column data can be added or subtracted.'''    global x, y, newx, newy    xl.Range(s1).Select()    x = MakeListFromColumn()    xl.Range(s2).Select()    y = MakeListFromColumn()    tck = splrep(x, y)  # spline made from original data (s1,s2)    xl.Range(timevector).Select()    timevector = MakeListFromColumn()    newy = [splev(i, tck) for i in timevector]    WriteColumn(target, timevector)    xl.Range(target).Select()    xl.ActiveCell.Offset(1, 2).Select()    newy = [float(i) for i in newy]    for entry in newy:        xl.ActiveCell.Value = entry        xl.ActiveCell.Offset(2, 1).Select()def ExactDegrees(s1, s2, target):    global x, y, newx, newy    xl.Range(s1).Select()    x = MakeListFromColumn()    xl.Range(s2).Select()    y = MakeListFromColumn()    tck = splrep(x, y)    newx = np.arange(0, 361, 1)    newy = [splev(i, tck) for i in newx]    WriteColumn(target, newx)    xl.Range(target).Select()    xl.ActiveCell.Offset(1, 2).Select()    newy = [float(i) for i in newy]    for entry in newy:        xl.ActiveCell.Value = entry        xl.ActiveCell.Offset(2, 1).Select()def dupremover(i, j, k):    global t, D, A, time, Disp, Accel    time = []    Disp = []    Accel = []    select(i)    t = MakeListFromColumn()    select(j)    D = MakeListFromColumn()    select(k)    A = MakeListFromColumn()    A = [round(i[0], 3) for i in A]    for i in range(len(A)):        if not i:            time.append(t[i])            Disp.append(D[i])        if i:            if A[i] != A[(i - 1)]:                time.append(t[i])                Disp.append(D[i])def DupElim(s, *args):    '''From the Excel cell specified as "s1", select the column    pair and remove duplicates including those that are approximately    equal. Write the result into the active worksheet beginning at    the upperleft corner in the user specified cell passed as "s2".'''    global C1, C2, data, l, l1, NewC1, NewC2    select(s)    C1 = MakeListFromColumn()    select(s)    xl.ActiveCell.Offset(1, 2).Select()    C2 = MakeListFromColumn()    data = list(zip(C1, C2))    comparray = []    eval1 = np.isclose(data[0], data[1])    comparray.append(eval1[0])    i = 0    while i < (len(data) - 1):        eval = np.isclose(data[i], data[i + 1])        # print eval        comparray.append(eval[0])        i += 1    l1 = [a for a, b in zip(data, comparray) if not b]    NewC1 = []    NewC2 = []    for obj in l1:        NewC1.append(obj[0])        NewC2.append(obj[1])    if args:        select(args[0])        WriteColumn(args[0], NewC1)        WriteColumn('e1', NewC2)def RemoveDupTimes(arg, target):    ''' From the source cell 'target', select two columns consisting of time and data. Make an ordered dictionary    to create unique key/value pairs. Write the new values in the range beginning at the cell 'Target'    :param arg:    :param target:    :return:    '''    from operator import itemgetter    global comparray, l, data, DataDict    select(arg)    C1 = MakeListFromColumn()    # C1 = [round(i, 3) for i in C1]    select(arg)    xl.ActiveCell.Offset(1, 2).Select()    C2 = MakeListFromColumn()    # data = zip(C1, C2)    DataDict = OrderedDict(list(zip(C1, C2)))    t = list(DataDict.keys())    v = list(DataDict.values())    WriteColumn(target, list(DataDict.keys()))    select(target)    xl.ActiveCell.Offset(1, 2).Select()    WriteColumnFromSelected(list(DataDict.values()))def removespaces(seq):    return [i.strip() for i in seq]def integ(x, tck):    '''Need to use the make spline function first in order    to generate the xvalues/yvalues pair and to create the    'tck' spline to itegrate'''    global out    out = [interpolate.splint(0, i, tck) for i in xvalues]    # return outdef smoothListGaussian(list, degree):    window = degree * 2 - 1    weight = np.array([1.0] * window)    weightGauss = []    for i in range(window):        i = i - degree + 1        frac = i / float(window)        gauss = 1 / (np.exp((4 * (frac)) ** 2))        weightGauss.append(gauss)    weight = np.array(weightGauss) * weight    smoothed = [0.0] * (len(list) - window)    for i in range(len(smoothed)):        smoothed[i] = sum(np.array(list[i:i + window]) * weight) / sum(weight)    return smootheddef xform(seq):    global x, length, FFT, freqs    import scipy as sy    # import scipy.fftpack as syfp    import pylab as pyl    seq = np.array(seq)    length = len(seq)    # Create time data for x axis based on array length    x = sy.linspace(0.001, length * 0.001, num=length)    # Do FFT analysis of array    FFT = np.fft.fft(seq)    # Getting the related frequencies    freqs = np.fft.fftfreq(seq.size, d=(x[1] - x[0]))    # print freqs    # Create subplot windows and show plot    # pyl.subplot(211)    # pyl.plot(x, seq)    # pyl.subplot(212)    # pyl.plot(freqs, sy.log10(FFT), 'x')    pyl.plot(freqs, sy.log10(FFT), 'x')    pyl.show()def filter(seq):    import scipy    N = 4    Fs = len(seq)    h = scipy.signal.firwin(numtaps=N, cutoff=10, nyq=Fs / 2)    y = scipy.signal.lfilter(h, 1.0, seq)    return ydef savgol(obj, window, order):    ''' applies a Savitzky-Golay filter to an array    --> obj should be from makespline(***)'''    from scipy.signal import savgol_filter as flt    out = flt([obj[0], obj[1]], window, order)    plt.grid()    plt.plot(out[0], out[1])def linearfit(seq1, seq2):    coefficients = np.polyfit(seq1, seq2, 1)    polynomial = np.poly1d(coefficients)    return polynomial(seq1)def intx2(t, a):    global Vcorrected    makespline(t, a)    integ(xvalues, tck)    fit = linearfit(xvalues, out)    Vcorrected = [(i - j) for i, j in zip(out, fit)]    # tck = splrep(xvalues,Vcorrected)    integ(xvalues, splrep(xvalues, Vcorrected))def sqnce(s1):    'Makes a linear series from the column selected'    select(s1)    return MakeListFromColumn()def Derivative(s1, s2, d, t1):    '''Make a spline from column s1&s2    --->take dth derivative of spline    ---> Write Data to column target t1'''    makespline(s1, s2)    seq = deriv(xvalues, tck, d)    WriteColumn(t1, seq)def TwoDerivs(s1):    '''From the target cell 's1' (column of time values)    and with a column of displacement values in the next    column to the right,velocity and acceleration values    are calculated and written as subsequent columns to    the right.    usage-->TwoDerivs('rowcolumn target')--> TwoDerivs('g2')    '''    global t, x, V, A    t = sqnce(s1)    SelectEndRight(s1)    x = MakeListFromColumn()    def WriteCol(seq):        for i in seq:            xl.ActiveCell.Value = i            xl.ActiveCell.Offset(2, 1).Select()    tck = splrep(t, x)    V = deriv(t, tck, 1)    A = deriv(t, tck, 2)    SelectEndRight(s1)    xl.ActiveCell.Offset(1, 2).Select()    WriteCol(V)    SelectEndRight(s1)    xl.ActiveCell.Offset(1, 2).Select()    WriteCol(A)def NoUnits(s1):    '''Given a source cell at the top of a column in Excel    removes the last two characters from each item in the column    and rewrites the values back into the column'''    l = sqnce(s1)    l1 = [i[:-2] for i in l]    WriteColumn(s1, l1)def SelRange(*arg):    '''Selects Current continuous Region within an excel worksheet    see also RegionSelect    '''    def dorange():        xl.Range(xl.Selection, xl.Selection.End(xlDown)).Select()        xl.Range(xl.Selection, xl.Selection.End(xlToRight)).Select()    if arg:        # 'select' is function I wrote        select(arg[0])        dorange()    if not arg:        xl.ActiveCell.Select()        dorange()def Basis(camval, columnhead):    global l1, l2    select(columnhead)    l1 = MakeListFromColumn()    l2 = [i * camval for i in l1]    WriteColumn(columnhead, l2)def ListDiff(s1, s2):    '''    '''    global UniqueItems, NotinListOne, NotinListTwo    select(s1)    L1 = MakeListFromColumn()    L1 = set(L1)    select(s2)    L2 = MakeListFromColumn()    L2 = set(L2)    UniqueItems = L1 ^ L2    NotinListOne = UniqueItems - L1    NotinListTwo = UniqueItems - L2def histogram(xcol, *args):    global x, numBins, IQR, IQRX, UpperCutoff, LowerCutoff, newdata, h    global initialrange, initialmean, finalrange, k    userbindefined = 0    if args:        numBins = float(args[0])        userbindefined = 1    def InterquartileRange(x):        return np.percentile(x, 75) - np.percentile(x, 25)    select(xcol)    dta = MakeListFromColumn()    dta = [float(i) for i in dta]    x = list(dta)    initialmean = np.mean(x)    IQRX = InterquartileRange(x)    UpperCutoff = np.mean(x) + 1.5 * IQRX    LowerCutoff = np.mean(x) - 1.5 * IQRX    newdata = []    for i in x:        if i > LowerCutoff:            if i < UpperCutoff:                newdata.append(i)    IQR = InterquartileRange(newdata)    h = 2 * IQR / (len(newdata) ** (1 / 3))    # if not usebindefined:    # numBins=(max(newdata)-min(newdata))/h    finalrange = (max(newdata) - min(newdata))    if not userbindefined:        global k        k = 1 + log(len(newdata), 2)        numBins = finalrange / k        # numBins=round(sqrt(len(newdata)))    fig = plt.figure()    ax = fig.add_subplot(111)    ax.grid()    ax.hist(newdata, numBins, color='green', alpha=0.8)    ax.axvline(np.mean(newdata), color='r', ls='dashed', linewidth=1)    plt.show()def multiaxisplot(xaxis, y1, y2, y3):    global ax1, ax2    fig = plt.figure()    ax1 = fig.add_subplot(111)    plt.grid()    ax1.plot(xaxis, y1)    ax1.plot(xaxis, y2)    ax2 = ax1.twinx()    ax2.plot(xaxis, y3)    y1min = ax1.get_ylim()[0]    y1max = ax1.get_ylim()[1]    y2min = ax2.get_ylim()[0]    y2max = ax2.get_ylim()[1]    new_y1min = (y2min * y1max) / y2max    new_y1max = (y1min * y2max) / y2min    # print new_y1min    ax1.set_ylim(new_y1min, new_y1max)    ax2minscale = ax2.get_ylim()[0] / ax1.get_ylim()[0]    ax2maxscale = ax2.get_ylim()[1] / ax1.get_ylim()[1]    # print ax2minscale,ax2maxscale    plt.draw()    plt.show()def SyteDict():    global cost, HybridBOM, costlookup, total    select('b2')    a = MakeListFromColumn()    aprime = []    for obj in a:        if not isinstance(obj, float):            aprime.append(obj.strip())        if isinstance(obj, float):            aprime.append(obj)    select('f2')    b = MakeListFromColumn()    cost = dict(list(zip(aprime, b)))    select('p1')    HybridBOM = MakeListFromColumn()    costlookup = [cost[i] for i in HybridBOM]    WriteColumn('s1', costlookup)    select('r1')    qty = MakeListFromColumn()    ExtendedCost = [i * j for i, j in zip(qty, costlookup)]    WriteColumn('T1', ExtendedCost)    total = sum(ExtendedCost)    select('t1')    xl.Selection.End(xlDown).Select()    xl.ActiveCell.Offset(2, 1).Select()    xl.Selection.Value = totaldef dothis():    from scipy.signal import savgol_filter as flt    window = 503    order = 3    select('c15')    t = MakeListFromColumn()    select('h15')    J1 = MakeListFromColumn()    select('i15')    J2 = MakeListFromColumn()    select('j15')    J3 = MakeListFromColumn()    tck1 = splrep(t, J1)    tck2 = splrep(t, J2)    tck3 = splrep(t, J3)    out1 = flt([tck1[0], tck1[1]], window, order)    out2 = flt([tck2[0], tck2[1]], window, order)    out3 = flt([tck3[0], tck3[1]], window, order)    plt.subplot(211)    plt.grid()    plt.plot(out1[0], out1[1], label='%s' % 'J1')    plt.plot(out2[0], out2[1], label='%s' % 'J2 ')    plt.plot(out3[0], out3[1], label='%s' % 'J3 ')    plt.legend(loc='best')    plt.show()    # savgol(tck3,503,3)def weightavg(obj):    '''selects a column of data from Excel and makes a histogram    using the histogram data, calculates a weighted average    according to sum((number of occurences)*weight)/Number of occurences    --> usage weightavg('xnn')    optimal number of bins is determined the Freedman-Diaconis rule    '''    global dta, a, numer, Wavg, x, y, h    select(obj)    dta = MakeListFromColumn()    dta = [float(i) for i in dta]    IQR = np.percentile(dta, 75) - np.percentile(dta, 25)    h = 2 * IQR * (len(dta)) ** -(1 / 3.)    bins = (max(dta) - min(dta)) / h    a = np.histogram(dta, bins)    x = [float(i) for i in a[0]]    y = [float(i) for i in a[1]]    numer = [(i * j) for i, j in zip(x, y)]    numer = sum(numer)    denom = sum(x)    Wavg = numer / denom    # print Wavgdef ColumnRescale(target, rescalevalue):    '''Selects an entire column of data at selection "target", unitizes the data and multiplies thru by the    rescalevalue. Rewrites new data back into the same space in the sheet    :param target:    :param rescalevalue:    :return:    '''    global l    select(target)    l = MakeListFromColumn()    v = max([abs(i) for i in l])    l = [(i / v) * rescalevalue for i in l]    WriteColumn(target, l)def RegionSelect():    ''' selects a continuous region from the active cell in an excel worksheet'''    xl.ActiveCell.CurrentRegion.Select()def Lsubtract(seq):    '''(i+1)-i for i in list'''    lst = []    for n in range(len(seq) - 1):        lst.append(seq[(n + 1)] - seq[n])    return lstdef toClipBoard(seq):    import win32clipboard as cb    cb.OpenClipboard()    cb.EmptyClipboard()    seq = [str(i) for i in seq]    cb.SetClipboardData(cb.CF_TEXT, str(seq))    cb.CloseClipboard()def DFT(x):    ''' x is the beginning of the excel column containing the values    :param x:    :return:    '''    from scipy import fftpack    global values    select(x)    x = MakeListFromColumn()    x = [float(i) for i in x]    f_s = float(1 / len(x))    # f_s = 500    values = x    X = fftpack.fft(values)    freqs = fftpack.fftfreq(len(values)) * f_s    fig, ax = plt.subplots()    ax.stem(freqs, np.abs(X))def DFT_slow(x):    """Compute the discrete Fourier Transform of the 1D array x"""    x = np.asarray(x, dtype=float)    N = x.shape[0]    n = np.arange(N)    k = n.reshape((N, 1))    M = np.exp(-2j * np.pi * k * n / N)    return np.dot(M, x)def dispToRad(R):    select('D10')    xl.Range(xl.Selection, xl.Selection.End(xlToRight)).Select()    data = xl.Selection()    seq = [obj for obj in data[0]]    Radseq = [(i / R) for i in seq]    select('D10')    WriteRowFromSelected(Radseq)def radToDisp(R):    select('D10')    xl.Range(xl.Selection, xl.Selection.End(xlToRight)).Select()    data = xl.Selection()    seq = [obj for obj in data[0]]    Radseq = [(i * R) for i in seq]    select('D10')    WriteRowFromSelected(Radseq)# xl.Range("A1").Select()# cellvalue=xl.ActiveCell.Value# print type(cellvalue)# if type(cellvalue) is NoneType:# print 'Nothing'# if isinstance(cellvalue,(float,unicode)):# print "found some type of something"# xl.Range(xl.Selection, xl.Selection.End(xlToRight)).Select()# seq=xl.Selection()# seq=list(seq)# seq=seq[0]# Unityseq=[obj/seq[-1] for obj in seq]# print Unityseq# xl.Range("B2").Select()# xl.Range(xl.Selection, xl.Selection.End(xlDown)).Select()# inputrange=xl.Selection# rangelist=[item.Address for item in inputrange]# start=rangelist[0]# end=rangelist[3]# value="B2:B6"# xl.Range(value).Sort(Key1=xl.Range("B2"), Orientation=1)# A.Sort(xl.Range(xl.Range(A),xlAscending,Header = xlYes))# xl.Range("B2:B6").Sort()# xl.Range(xl.Selection, xl.Selection.End(xlToRight)).Select()# InputRange=xl.Selection# xl.Range("C17").Select()# xl.Range(xl.Selection, xl.Selection.End(xlDown)).Select()# InputRange=xl.Selection# Group=[column for column in InputRange.Columns()]# print Group# xl.Range("F17").Select()# xl.ActiveCell.Offset(len(InputRange),1).Select()# TimeRange=xl.Range(xl.Selection,xl.Cells(17,6)).Select()# TimeRange=xl.Selection# Time=[column for column in TimeRange.Columns()]# print Time# xl.Selection.ClearContents()# xl.Range("A1").Select()# xl.Range(xl.Selection, xl.Selection.End(xlToRight)).Select()# xl.Range(xl.Selection, xl.Selection.End(xlDown)).Select()# InputRange=xl.Selection# DRange=[column for column in InputRange.Columns()]if __name__ == '__main__':    #makespline('f72', 'e72')    # dispToRad(28)    # seq = [0, .39, .41, .5, .85, .92, 1]    # DFT('b1')    # Lsubtract(seq)    # RegionSelect()    # xl.Selection.End(xlToRight).Select()    # xl.Selection.End(xlDown).Select()    # xl.Range(xl.Selection, xl.Selection.End(xlToRight)).Select()    # xl.Range(xl.Selection, xl.Selection.End(xlDown)).Select()    # DataRange=xl.Selection    # DRange = [column for column in DataRange.Columns()]    # RemoveDupTimes('a1', 'd1')    # f='c:\\BOM\\tmp.xls'    # wb = open_workbook(f)    # XYZClean()    # TwoColumnClean()    # unitize('B1','D1')    # ColumnRescale('a4',120)    pass    # makespline('a1','b1')    # integ(xvalues,tck)    # ExactDegrees('a1','b1','d1')    # ExactPoints('a1','b1')    # weightavg('i15')    # pass    # histogram('i15')    # pcentile('f2',85)    # DupElim('a1','d1')    # ExactPoints('b1','c1',250,'d1')    # l=removespaces(d)    # dataParse(l)